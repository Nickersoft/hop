{
  "version": 3,
  "sources": ["../src/cli.ts", "../src/buildApp.ts", "../src/resolveApp.ts", "../src/validateManifest.ts", "../src/installApp.ts"],
  "sourcesContent": ["import { Command } from \"commander\";\n\nimport ora from \"ora\";\nimport buildApp from \"./buildApp\";\n\nimport resolveApp from \"./resolveApp\";\nimport installApp from \"./installApp\";\n\nconst program = new Command();\n\nprogram\n  .version(\"0.0.1\")\n  .command(\"install\")\n  .argument(\"<apps...>\")\n  .option(\"-f, --overwrite\", \"overwrites the app if it already exists\")\n  .action((apps, { overwrite }) => {\n    Promise.all(\n      apps.map(async (appName) => {\n        const spinner = ora(`Resolving formula '${appName}'...`).start();\n\n        let cleanup = () => {};\n\n        try {\n          const app = await resolveApp(appName);\n          const name = app.manifest.name;\n\n          spinner.text = `Building ${name}...`;\n\n          const { path: appPath, cleanup: appCleanup } = await buildApp(app);\n\n          cleanup = appCleanup;\n\n          spinner.text = `Installing ${name}...`;\n\n          const force = overwrite ?? false;\n\n          installApp(appPath, force);\n\n          spinner.text = `Cleaning up...`;\n\n          cleanup();\n\n          spinner.succeed(`Successfully installed ${name}!`);\n        } catch (error) {\n          spinner.fail(\n            `Failed to install ${appName} with error: \"${error.toString()}\"`\n          );\n          cleanup();\n        }\n      })\n    );\n  });\n\nprogram.parse(process.argv);\n", "import tmp from \"tmp\";\n\nimport { buildNativefierApp } from \"nativefier\";\nimport { App } from \"./types\";\n\nexport default ({\n  manifest,\n  cleanup: appCleanup,\n  icon,\n}: App): Promise<{ path: string; cleanup: () => void }> => {\n  process.env[\"ELECTRON_ENABLE_LOGGING\"] = \"false\";\n\n  return new Promise((resolve, reject) => {\n    tmp.dir({ keep: true }, (err, path, cleanup) => {\n      if (err) {\n        reject(err);\n      } else {\n        buildNativefierApp({\n          name: manifest.name,\n          targetUrl: manifest.url,\n          platform: \"darwin\",\n          out: path,\n          ...(icon && { icon }),\n        })\n          .then((appPath) => {\n            if (appPath) {\n              resolve({\n                path: appPath,\n                cleanup: () => {\n                  cleanup();\n                  appCleanup();\n                },\n              });\n            } else {\n              reject(\n                new Error(\"App path is undefined! Not sure what happened :/\")\n              );\n            }\n          })\n          .catch((err) => reject(err));\n      }\n    });\n  });\n};\n", "import axios from \"axios\";\nimport yaml from \"js-yaml\";\nimport tmp from \"tmp\";\n\nimport { createWriteStream } from \"fs\";\n\nimport validateManifest from \"./validateManifest\";\n\nimport { App, AppManifest } from \"./types\";\n\nconst downloadIcon = async (\n  appName: string\n): Promise<{ path: string; cleanup: () => void }> => {\n  const url = `https://raw.githubusercontent.com/Nickersoft/hop/master/apps/${appName}/icon.png`;\n\n  return new Promise((resolve, reject) => {\n    tmp.dir({ keep: true }, (err, path, cleanup) => {\n      if (err) {\n        throw err;\n      } else {\n        const output = `${path}/icon.png`;\n\n        axios({\n          method: \"GET\",\n          url: url,\n          responseType: \"stream\",\n        })\n          .then(({ data }) => {\n            data.pipe(createWriteStream(output));\n\n            data.on(\"end\", () => {\n              resolve({ path: output, cleanup });\n            });\n\n            data.on(\"error\", (err) => {\n              reject(err);\n            });\n          })\n          .catch((err) => reject(err));\n      }\n    });\n  });\n};\n\nexport default async (appName: string): Promise<App> => {\n  const manifestUrl = `https://raw.githubusercontent.com/Nickersoft/hop/master/apps/${appName}/manifest.yml`;\n\n  try {\n    const { data } = await axios.get(manifestUrl);\n\n    let icon: null | string = null;\n    let cleanupFunc = () => {};\n\n    // Attempt to download the app icon if it exists\n    try {\n      const { path, cleanup } = await downloadIcon(appName);\n\n      icon = path;\n      cleanupFunc = cleanup;\n    } catch (error) {}\n\n    const config = yaml.load(data);\n\n    if (!validateManifest(config as object)) {\n      throw new Error(\n        `Invalid manifest found for ${appName}. Skipping installation`\n      );\n    }\n\n    return { manifest: config as AppManifest, icon, cleanup: cleanupFunc };\n  } catch (error) {\n    if (error.response.status === 404) {\n      throw new Error(`Couldn't find app: ${appName}. Skipping installation.`);\n    } else {\n      throw error;\n    }\n  }\n};\n", "import Ajv, { JSONSchemaType } from \"ajv\";\n\nimport addFormats from 'ajv-formats';\n\nimport { AppManifest } from \"./types\";\n\nconst schema: JSONSchemaType<AppManifest> = {\n  type: \"object\",\n  properties: {\n    name: { type: \"string\" },\n    url: { type: \"string\", format: \"uri\" },\n    icon: { type: \"string\", nullable: true }\n  },\n  required: [\"name\", \"url\"],\n  additionalProperties: false,\n};\n\nconst ajv = new Ajv();\n\naddFormats(ajv);\n\nconst validate = ajv.compile(schema);\n\nexport default (obj: object) => validate(obj);", "import { readdirSync, moveSync } from \"fs-extra\";\nimport { join } from \"path\";\n\nexport default (appPath: string, overwrite: boolean = false) => {\n  const files = readdirSync(appPath);\n  const file = files.filter((filter) => filter.endsWith(\".app\"))?.[0];\n\n  if (!file) {\n    throw new Error(\"Could not find app in build directory!\");\n  }\n\n  moveSync(join(appPath, file), `/Applications/${file}`, { overwrite });\n};\n"],
  "mappings": "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",
  "names": []
}
