{
  "version": 3,
  "sources": ["../src/cli.ts", "../src/commands/index.ts", "../src/commands/ls.ts", "../src/octokit.ts", "../src/config.ts", "../src/commands/install.ts", "../src/commands/utils/buildApp.ts", "../src/commands/utils/createTempDir.ts", "../src/commands/utils/installApp.ts", "../src/commands/utils/resolveApp.ts", "../src/commands/utils/validateManifest.ts"],
  "sourcesContent": ["import { Command } from \"commander\";\n\nimport * as commands from \"./commands\";\n\nconst program = new Command();\n\nObject.values(commands).forEach((command) => program.addCommand(command));\n\nprogram.parse(process.argv);\n", "export * from \"./ls\";\nexport * from \"./install\";\n", "import ora from \"ora\";\n\nimport { Command } from \"commander\";\n\nimport octokit from \"../octokit\";\nimport config from \"../config\";\n\nexport const ls = new Command(\"ls\").action(async () => {\n  const spinner = ora({ hideCursor: true }).start();\n\n  const { data } = await octokit.rest.repos.getContent({\n    owner: config.repo.owner,\n    repo: config.repo.name,\n    path: \"apps\",\n  });\n\n  spinner.stop();\n\n  console.log(\"\\nAvailable Apps:\\n===============\\n\");\n\n  // @ts-expect-error\n  const names = data.map(({ name }) => `- ${name}`).sort();\n\n  console.log(names.join(\"\\n\"));\n  console.log(\"\\n\");\n});\n", "import { Octokit } from \"@octokit/rest\";\n\nexport default new Octokit();\n", "export default {\n  repo: {\n    owner: \"Nickersoft\",\n    name: \"hop\",\n  },\n  defaultUserAgent:\n    \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36\",\n};\n", "import ora from \"ora\";\n\nimport { Command } from \"commander\";\n\nimport { resolveApp, buildApp, installApp } from \"./utils\";\n\nexport const install = new Command(\"install\")\n  .argument(\"<apps...>\")\n  .option(\"-f, --overwrite\", \"overwrites the app if it already exists\")\n  .action((apps, { overwrite }) => {\n    Promise.all(\n      apps.map(async (appName) => {\n        const spinner = ora(`Resolving app '${appName}'...`).start();\n\n        let cleanup = () => {};\n\n        try {\n          const app = await resolveApp(appName);\n          const name = app.manifest.name;\n\n          spinner.text = `Building ${name}...`;\n\n          const { path: appPath, cleanup: appCleanup } = await buildApp(app);\n\n          cleanup = appCleanup;\n\n          spinner.text = `Installing ${name}...`;\n\n          const force = overwrite ?? false;\n\n          installApp(appPath, force);\n\n          spinner.text = `Cleaning up...`;\n\n          cleanup();\n\n          spinner.succeed(`Successfully installed ${name}!`);\n        } catch (error) {\n          spinner.fail(\n            `Failed to install ${appName} with error: \"${error.toString()}\"`\n          );\n          cleanup();\n        }\n      })\n    );\n  });\n", "import config from \"../../config\";\n\nimport { buildNativefierApp } from \"nativefier\";\nimport { App } from \"../../types\";\nimport { createTempDir } from \"./createTempDir\";\n\nexport const buildApp = async ({\n  manifest,\n  cleanup: appCleanup,\n  icon,\n}: App): Promise<{ path: string; cleanup: () => void }> => {\n  process.env[\"ELECTRON_ENABLE_LOGGING\"] = \"false\";\n\n  const { path, cleanup } = await createTempDir();\n\n  const appPath = await buildNativefierApp({\n    name: manifest.name,\n    targetUrl: manifest.url,\n    platform: \"darwin\",\n    internalUrls: \".*?\",\n    userAgent: config.defaultUserAgent,\n    out: path,\n    ...(icon && { icon }),\n    ...(manifest.titleBar === false && { titleBarStyle: \"hidden\" }),\n  });\n\n  if (appPath) {\n    return {\n      path: appPath,\n      cleanup: () => {\n        cleanup();\n        appCleanup();\n      },\n    };\n  } else {\n    throw new Error(\"App path is undefined! Not sure what happened :/\");\n  }\n};\n", "import tmp from \"tmp\";\n\nexport const createTempDir: () => Promise<{\n  path: string;\n  cleanup: () => void;\n}> = () =>\n  new Promise((resolve, reject) => {\n    tmp.dir({ keep: true }, (err, path, cleanup) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({ path, cleanup });\n      }\n    });\n  });\n", "import { readdirSync, moveSync } from \"fs-extra\";\nimport { join } from \"path\";\n\nexport const installApp = (appPath: string, overwrite: boolean = false) => {\n  const files = readdirSync(appPath);\n  const file = files.filter((filter) => filter.endsWith(\".app\"))?.[0];\n\n  if (!file) {\n    throw new Error(\"Could not find app in build directory!\");\n  }\n\n  moveSync(join(appPath, file), `/Applications/${file}`, { overwrite });\n};\n", "import axios from \"axios\";\nimport yaml from \"js-yaml\";\n\nimport { createWriteStream } from \"fs\";\n\nimport { validateManifest } from \"./validateManifest\";\nimport { createTempDir } from \"./createTempDir\";\n\nimport { App, AppManifest } from \"../../types\";\n\nconst downloadIcon = async (\n  appName: string\n): Promise<{ path: string; cleanup: () => void }> => {\n  const url = `https://raw.githubusercontent.com/Nickersoft/hop/master/apps/${appName}/icon.png`;\n\n  const { path, cleanup } = await createTempDir();\n\n  const output = `${path}/icon.png`;\n\n  const { data } = await axios({\n    method: \"GET\",\n    url: url,\n    responseType: \"stream\",\n  });\n\n  data.pipe(createWriteStream(output));\n\n  return new Promise((resolve, reject) => {\n    data.on(\"end\", () => {\n      resolve({ path: output, cleanup });\n    });\n\n    data.on(\"error\", (err) => {\n      reject(err);\n    });\n  });\n};\n\nexport const resolveApp = async (appName: string): Promise<App> => {\n  const manifestUrl = `https://raw.githubusercontent.com/Nickersoft/hop/master/apps/${appName}/manifest.yml`;\n\n  try {\n    const { data } = await axios.get(manifestUrl);\n\n    let icon: null | string = null;\n    let cleanupFunc = () => {};\n\n    // Attempt to download the app icon if it exists\n    try {\n      const { path, cleanup } = await downloadIcon(appName);\n\n      icon = path;\n      cleanupFunc = cleanup;\n    } catch (error) {}\n\n    const config = yaml.load(data);\n\n    if (!validateManifest(config as object)) {\n      throw new Error(\n        `Invalid manifest found for ${appName}. Skipping installation`\n      );\n    }\n\n    return { manifest: config as AppManifest, icon, cleanup: cleanupFunc };\n  } catch (error) {\n    if (error.response.status === 404) {\n      throw new Error(`Couldn't find app: ${appName}. Skipping installation.`);\n    } else {\n      throw error;\n    }\n  }\n};\n", "import Ajv, { JSONSchemaType } from \"ajv\";\n\nimport addFormats from \"ajv-formats\";\n\nimport { AppManifest } from \"../../types\";\n\nconst schema: JSONSchemaType<AppManifest> = {\n  type: \"object\",\n  properties: {\n    name: { type: \"string\" },\n    description: { type: \"string\" },\n    url: { type: \"string\", format: \"uri\" },\n    icon: { type: \"string\", nullable: true },\n    titleBar: { type: \"boolean\", default: true, nullable: true },\n  },\n  required: [\"name\", \"url\"],\n  additionalProperties: false,\n};\n\nconst ajv = new Ajv();\n\naddFormats(ajv);\n\nconst validate = ajv.compile(schema);\n\nexport const validateManifest = (obj: object) => validate(obj);\n"],
  "mappings": "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",
  "names": []
}
